- UI 관련

object에서 alt를 누른 상태로 object를 이동시키면 ctrl + c, ctrl + v를 한 것과 같은 효과가 난다.

viewport에서 특정 object를 선택하고 레벨 블루프린트에서 노드 추가를 누르면 선택한 object에 대한 참조 객체 노드(get object)를 생성할 수 있다.

게임 시작 후 F8을 누르면 게임은 실행되고 있는 상태에서 Unreal 뷰포트 처럼 오브젝트의 위치를 옮길 수 있다.

view mode를 player collision으로 하면 물리가 실제로 적용되는 충돌체의 정확한 모양을 볼 수 있다.

블루프린트 노드들을 다중 선택하고 C키를 누르면 해당 노드들이 블록으로 묶어지면서 주석이 생긴다.

블루프린트 노드들을 다중 선택하고 우측 클릭을 하고 Collapse to Funtion을 하면 해당 노드들이 모두 묶인 함수가 생성된다.

블루프린트에서 직접 만든 함수들 속성에 Pure라는 것이 있는데 이게 체크 되어 있으면 함수의 실행 핀이 사라진다. 즉 전체적인 블루프린트 로직 흐름에 관여하는 함수가 아니라 값만 반환해주는 함수로 바뀌는 것이다.
예를 들어 "총알의 개수가 0개 초과면 true 아니면 false 반환"와 같은 함수가 Pure Function이 될 수 있다. 주의할 점은 함수의 side effect가 없는 경우에만 Pure 속성을 적용해야 한다는 것이다.
만약에 "총알의 개수가 0개 초과면 true 아니면 현재 총알의 개수를 5개 추가시키고 false 반환" 이러한 함수는 bool형인 반환값 이외의 총알 개수라는 int형 변수의 상태를 변화시키고 있다. 즉 총알 개수를 바꾸면서 블루프린트 로직 흐름에 직접적인 영향을 끼치므로 Pure 속성을 사용하면 안된다.

프로젝트 자체 설정에 대한 것은 에디터 메뉴바의 Edit -> Project Settings를 이용한다.
언리얼 에디터 설정에 대한 것은 에디터 메뉴바의 Edit -> Editor Preferences를 이용한다.

- 용어 설명

object: 데이터 집합
actor: 레벨에 배치할 수 있는 object
component: actor에 부착(확장)할 수 있는 object
game mode: 게임의 규칙을 정해놓는 actor이다. 규칙이라 하면 적이 어떤 곳에 어떻게 어느 방향으로 어느 순간에 배치되어야 하는지, 플레이어가 어디서 스폰되어야 하는지, 멀티 플레이어 게임에서는 한 세션에 몇 명까지 허용하는지 등이 있다.

- Game Mode 관련
언리얼 에디터 상단 왼쪽에 Select Mode라는 곳 옆에 보면 아이콘 몇개가 있을 텐데 블루프린트 노드 3개가 연결된 것 같이 생긴 아이콘이 있을 것이다.
이를 눌러보면 레벨 블루프린트, 프로젝트 게임 모드, 월드 게임 모드를 지정할 수가 있다.
레벨 블루프린트는 해당 Scene에서 작동하는 블루 프린트다.
프로젝트 게임 모드는 지금 만들고 있는 게임에서 모두 쓰이는 게임 모드이다.
월드 게임 모드는 특정 Scene에서만 쓰이는 게임 모드이다.
월드 게임 모드가 지정되면 프로젝트 게임 모드는 작동하지 않는다.
지정된 월드 게임 모드가 없는 경우에만 프로젝트 게임 모드가 작동한다.
게임 모드의 디폴트 클래스 속성을 보면 Default Pawn Class가 있는데 이 녀석이 플레이어가 조종하는 Pawn을 결정한다.
Actor 종류에 Player Start라는 Actor가 있는데 이 녀석을 맵에 배치하고 플레이 해보면 게임 모드에서 지정된 Default Pawn Class 폰이 Player Start가 배치된 위치에서 스폰되는 것을 확인할 수 있다.

- 물리 관련

* force와 impluse의 차이 
force(충격력)는 흔히 알고 있는 물리식 f[충격력] = m[질량] * a[가속도] 에서 f로 절대적인 힘의 크기(단위)이다. 
반면 J(줄)이라고도 하는 impluse(충격량)은 force(충격력)의 시간에 따른 변화량이다. impluse(충격량)의 수식은 J[충격량] = f[평균 힘] * (t2[끝 시각] - t1[시작 시각])

* Add Force 함수
매 프레임마다 호출하는 것을 전제로 만든 함수이다. 
예를 들어 당신의 게임이 60fps인데 100의 힘을 특정 물체에게 1초 동안 가하고 싶다면 Add Force 함수에 입력되는 힘에 100 * 60을 넣거나 Add Force 함수를 틱마다 호출하는데 이를 60번 반복하면 된다.(즉 실제 게임 시간 1초 동안 Add Force를 호출하면 된다.)
해당 함수에는 Accel Change 파라메터가 있는데 해당 파라메터가 체크되면 오브젝트의 질량이 1로 고정되어 f = 1 * a로 순수 힘만 영향을 주게 된다.
Accel Change이 체크된 상태에서 Add Force에 X축으로 100의 힘을 가한다고 하자 그려면 100 = 1 * a가 되고 a는 100(단위는 이해를 위해 m/s라고 하자)m/s가 되는데 해당 Add Force 함수를 1초 동안 수행시켜 줘야 Add Force가 된 물체는 100m/s에 도달할 것이다.

* Add Impulse 함수
프레임 상관없이 호출하는 것을 전제로 만든 함수이다. 
당신의 게임이 60fps인 경우에 Add Force에 100 * 60을 한 결과와 Add Impulse에 100을 한 결과는 같다. 
해당 함수에는 Vel Change가 있는데 Add Force 함수의 Accel Change 파라메터와 같이 체크되면 오브젝트의 질량을 1로 고정하여 순수 힘만 영향을 주게 된다. 
질량을 고정하는건 같은데 이름이 다른 이유는 다음과 같다. 
Accel Change가 체크된 Add Force 함수의 수식은 원래의 식 f = m * a에서 질량(m)이 1로 무시되어 f = 1 * a = a 요렇게 된다.
Vel Change가 체크된 Add Impulse 함수의 수식은 원래의 식 f = m * a[v * t]에서 질량(m)과 시간(t)이 1로 무시되어 f = 1 * v * 1 = v 요렇게 된다.
Vel Change가 체크된 상태에서 Add Impulse에 X축으로 100의 힘을 가한다고 하자 그려면 100 = 1 * v * 1가 되고 v는 100(단위는 이해를 위해 m/s라고 하자)m/s가 되는데 해당 Add Impulse 함수를 실행한 그 tick에 바로 Add Impulse가 된 물체는 100m/s에 도달할 것이다.

* 단위
언리얼에서 거리를 다룰 때 숫자 1은 1cm을 말한다. 즉 100은 1m이다.

- 인 게임 관련

게임이 시작될 때 자동으로 생성되는 default pawn의 rotation은 고정이다. 따라서 마우스를 움직여 카메라의 시점 위치에 따라 default pawn의 rotation이 바뀔 것이라 생각하는 것은 큰 오산이다.
따라서 카메라 이동에 따른 rotation을 구할 때는 get Actor rotation 말고 get control rotation을 사용해야 한다.
참고로 get control rotation 함수는 언리얼 공식 문서에서 aim rotation이라고 설명이 되어 있는데 컨트롤러를 통해 우리가 게임을 볼 때 마우스가 향하고 있는 곳의 rotation을 반환하는 것이라고 봐도 무방할 것이다.

- 언리얼 버그 관련

언리얼에서 에셋을 추가할 때 맵이 함께 들어있는 에셋들이 있을 것이다. 해당 에셋의 맵을 그냥 더블클릭해서 열려고 하면 진행 상황 표시 창이 멈춰서 어디까지 진행이 되었는지도 모르고 맵이 열리기 까지 굉장히 오래 걸려서 답답한데 이를 해결하기 위해서는 그냥 해당 맵을 한번만 클릭하고 우측클릭을 누르면 언리얼엔진 밑에 쉐이더를 로드하는 부분이 나타나고 해당 쉐이더가 다 읽힌 후에 맵을 더블클릭해서 열어보면 맵이 잘 출력되는 것을 볼 수 있다.

현재 언리얼 엔진 5에 버그가 있어서 새로운 C++ 클래스를 생성하는 경우 매우 주의하여야 한다. 
만약 C++ 클래스를 생성했다면 에디터를 닫고 해당 언리얼 프로젝트 폴더 경로로 들어가서 비주얼 스튜디오 프로젝트 파일인 .sln 파일을 열어준다. 
그 후에 Development Editor 솔루션 구성 상태에서 ctrl + f5로 빌드하고 실행하여 에디터를 연다. 
이렇게 해야만 생성한 C++ 클래스가 에디터에 유지된다. 
위의 방식을 사용하지 않고 C++ 클래스와 연동된 블루프린트를 만들고 작업을 진행한 후에 저장하고 언리얼 에디터를 종료하게 되면 후에 다시 언리얼 에디터를 킨 경우에 C++ 클래스가 에디터에서 사라져 기존에 만들어 놓았던 블루프린트가 부모 클래스를 찾지 못하게 되어 프로젝트 저장에 문제가 생긴다. 
해당 문제가 발생하면 부모 클래스가 없는 블루프린트는 에디터 내에서 삭제가 안돼서 특정 참조 파일을 일일이 경로로 지워주어야 하기에 반드시 사전 방지를 하자. 
추가적으로 해당 현상은 단순히 C++ 클래스의 소스 코드가 바뀐 경우도 포함되기 때문에 C++ 클래스가 새로 생성되거나 내용이 바뀌는 경우 모두 수행하는 것으로 하자.

- Geometry Brush (BSP)
Place Actor 패널에서 Geometry 오브젝트를 배치할 수 있는데 해당 지형 오브젝트들은 브러쉬 타입이 있다.
하나는 더하기, 하나는 빼기인데 이들을 잘 조합하여 지형을 굉장히 빠르게 만들 수 있다.
예를 들어 지형 오브젝트 박스를 판처럼 만들고 더하기 속성을 가지게 하고 게임 맵에 추가했다고 할 때 해당 판에 창문을 박고 싶다면 또 다른 지형 오브젝트 박스를 작은 네모로 만든 후에 빼기 속성을 가지게 하고 아까 만든 지형 판에 가져다가 두면 해당 창문 지형 오브젝트 크기만큼 판 오브젝트가 뚫린다.

- Actor 관련
하나의 Actor는 여러개의 static mesh를 가질 수 있다. 이때 정적 메쉬들의 부모 자식간의 관계가 중요한데 자식 메쉬는 부모 메쉬의 좌표계를 기준으로 움직이게 된다.
즉 부모의 transform 값과 자식의 transform 값은 다르다는 것이다. 부모 메쉬의 좌표가 0,100,200 이라 해도 부모 메쉬의 자식으로 새로운 메쉬를 달았다면 해당 새로운 자식 메쉬의 좌표는 0,0,0이다.
부모 메쉬에 연결되어 있는 모든 자식 메쉬까지 덩어리인 상태에서 정상적으로 물리를 한번에 적용하려면 부모 메쉬의 최상단에 위치한 엑터에만 물리를 활성화 시키고 나머지 스테틱 메쉬들의 물리는 꺼버리자. (각각의 메쉬들의 물리가 모두 활성화 되어 있으면 덩어리였던 물체들이 서로 낑겨 있는 것으로 판단되어 게임이 시작되자마자 사방으로 튕겨져 나갈 수 있다.)

- 충돌체 복잡성 문제
특정 리소스에서 가져온 메쉬에 물리를 활성화했는데 충돌이 불안정하다면 메쉬를 더블 클릭하여 메쉬 편집기에 들어가서 기존 충돌체를 지우고 충돌체에 맞는 형태의 간략화된 충돌체를 새로 지정해 줄 수 있다. (예를 들면 10DOP-Z simplified collision 등등...)

- 버전 관리 관련
Unreal Engine에서는 blueprint의 바이너리 파일 변경 문제를 다루는 것이 용이한 Perforce라는 형상 관리 시스템이 추천된다.
Perforce는 클라우드 시스템이 없고 직접 서버를 구축하여 활용해야 한다.
다른 방식으로는 git LFS를 이용하는 방법이 있다.
단순 git을 사용해서 Unreal Engine 프로젝트를 관리하게 몇가지 문제가 있는데 일단 Unreal Engine 프로젝트의 크기가 크기 때문에 각종 리퀘스트에 걸리는 시간들이 많이 늘어난다.
그리고 blueprint와 같은 바이너리 기능들에 수정이 가해진 것을 git에서 캐치하지 못하기 때문에 blueprint 수정 사항이 제대로 반영이 안될 뿐만 아니라 팀원끼리 같은 blueprint를 수정하고 merge를 하면 정상적으로 merge 진행이 안된다...
따라서 git을 사용하려면 바이너리 파일을 포함하여 대용량 파일들을 따로 관리해주는 git LFS를 함께 사용해야 한다.
사설 서버에서 git LFS를 사용하는 방법은 gitea와 gitlab이 있으며 gitea가 서버 리소스 사용량이 적기에 더 추천된다.
둘 중 어느 것을 사용하던 사설 서버를 구축하는 것이 맘 편하다.

- Player Controller 관련
Pawn에는 Auto Possess Player라는 옵션이 있는데 만약 플레이 시현을 했는데 자신이 구현한 주 캐릭터로 카메라가 이동하지 않고 캐릭터 자체도 컨트롤 반응이 없다면 해당 캐릭터의 Pawn 속성의 Auto Possess Player가 제대로 설정이 안되었는지 확인해보자.

- 빌드 관련
일단 Visual Studio로 빌드하기 위해서는 Editor Preferences에서 Source Code 탭에서 Visual Studio를 코드 편집 에디터로 설정해야 한다.
새로운 C++ 클래스를 작성하기 위해서는 에디터 메뉴바의 Tools -> New C++ Class를 선택한다.
새로운 C++ 클래스를 만들었다면 언리얼 엔진에서도 경고 창으로 알려주겠지만 에디터를 끄고 새로 추가된 클래스가 포함된 소스 코드를 빌드(Visual Studio에서는 Ctrl + B)하고 에디터를 다시 켜야 한다.
Visual Studio 2022의 17.4 버전부터는 VS IDE 코드 에디터에서 C++ 클래스가 어떤 블루프린트를 참조하고 있는지 추적해준다.
해당 기능을 이용하기 위해서는 언리얼 엔진 마켓 플레이스에서 "Visual Studio Integration Tool" 플러그인을 다운 받고 엔진 내부에서 플러그인을 활성화 시킨 다음에 에디터를 재시작하면 된다. (물론 VS 2022 17.4버전 이상이 설치되어 있어야 한다.)

- 자료형 관련
표준 C++에서 쓰던 자료형과 언리얼에서 쓰는 자료형은 좀 다르다.
표준 C++ <-> 언리얼 C++
int <-> int16, int32, int64
존재하지 않음 <-> FVector (언리얼 전용 벡터 클래스다. 정규화, 벡터 덧셈 연산, FVector::Dist()와 같은 클래스 정적 함수 등 많은 것이 포함됨.)

- FVector
GetSafeNormal() -> 정규화된 크기 1인 방향 벡터를 뽑아냄

- 언리얼 전용 함수, 매크로
SetActorLocation, GetActorLoaction -> 액터 방향 setter, getter
MoveUpdatedComponent -> 타겟이 특정 물체에 충돌할 때마다 주어진 Delta 만큼 움직여주고 Rotation 만큼 회전시켜주고 sweep이나 teleport 옵션에 따라 다양하게 움직여주는 하수

- C++ 클래스에서 부모 클래스 생성
만든 C++ 클래스에 우측 클릭 누르고 Create BluePrint Class Based on ... 누르면 된다.

- UPROPERTY
클래스 변수에 선언 위에 붙여주어 해당 변수를 언리얼 엔진 편집 창에 보여주거나 직접 인터페이스를 통해 편집할 수 있게 속성을 부여해주는 역할을 한다.
예시는 밑과 같다.
UPROPERTY(EditAnywhere)
int Velocity;
이렇게 하고 실제 Scene에 존재하는 해당 클래스 객체를 눌러보면 Details 창에 Velocity 변수 항목이 보일 것이다.
UPROPERTY에는 EditAnywhere 같은 다양한 속성 타입이 존재한다.

* EditAnywhere
언리얼 편집창에서 보이고 수정도 가능하다.

* VisibleAnywhere
언리얼 편집창에서 보이기만 하고 수정은 불가능하다.

* Category
변수에 카테고리 특성을 부여하는데 예를 들어 
UPROPERTY(EditAnywhere, Category="Physics Values")
int Velocity; 
라고 하면 언리얼 편집창에서 Details 창에 Physics Values 카테고리가 나타나고 해당 카테고리 안에 Velocity 변수값 조절 인터페이스가 있을 것이다.

