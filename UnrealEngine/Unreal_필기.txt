- UI 관련

object에서 alt를 누른 상태로 object를 이동시키면 ctrl + c, ctrl + v를 한 것과 같은 효과가 난다.

viewport에서 특정 object를 선택하고 레벨 블루프린트에서 노드 추가를 누르면 선택한 object에 대한 참조 객체 노드(get object)를 생성할 수 있다.

게임 시작 후 F8을 누르면 게임은 실행되고 있는 상태에서 Unreal 뷰포트 처럼 오브젝트의 위치를 옮길 수 있다.

view mode를 player collision으로 하면 물리가 실제로 적용되는 충돌체의 정확한 모양을 볼 수 있다.

블루프린트 노드들을 다중 선택하고 C키를 누르면 해당 노드들이 블록으로 묶어지면서 주석이 생긴다.

블루프린트 노드들을 다중 선택하고 우측 클릭을 하고 Collapse to Funtion을 하면 해당 노드들이 모두 묶인 함수가 생성된다.

블루프린트에서 직접 만든 함수들 속성에 Pure라는 것이 있는데 이게 체크 되어 있으면 함수의 실행 핀이 사라진다. 즉 전체적인 블루프린트 로직 흐름에 관여하는 함수가 아니라 값만 반환해주는 함수로 바뀌는 것이다.
예를 들어 "총알의 개수가 0개 초과면 true 아니면 false 반환"와 같은 함수가 Pure Function이 될 수 있다. 주의할 점은 함수의 side effect가 없는 경우에만 Pure 속성을 적용해야 한다는 것이다.
만약에 "총알의 개수가 0개 초과면 true 아니면 현재 총알의 개수를 5개 추가시키고 false 반환" 이러한 함수는 bool형인 반환값 이외의 총알 개수라는 int형 변수의 상태를 변화시키고 있다. 즉 총알 개수를 바꾸면서 블루프린트 로직 흐름에 직접적인 영향을 끼치므로 Pure 속성을 사용하면 안된다.

- 용어 설명

object: 데이터 집합
actor: 레벨에 배치할 수 있는 object
component: actor에 부착(확장)할 수 있는 object


- 물리 관련

* force와 impluse의 차이 
force(충격력)는 흔히 알고 있는 물리식 f[충격력] = m[질량] * a[가속도] 에서 f로 절대적인 힘의 크기(단위)이다. 
반면 J(줄)이라고도 하는 impluse(충격량)은 force(충격력)의 시간에 따른 변화량이다. impluse(충격량)의 수식은 J[충격량] = f[평균 힘] * (t2[끝 시각] - t1[시작 시각])

* Add Force 함수
매 프레임마다 호출하는 것을 전제로 만든 함수이다. 
예를 들어 당신의 게임이 60fps인데 100의 힘을 특정 물체에게 1초 동안 가하고 싶다면 Add Force 함수에 입력되는 힘에 100 * 60을 넣거나 Add Force 함수를 틱마다 호출하는데 이를 60번 반복하면 된다.(즉 실제 게임 시간 1초 동안 Add Force를 호출하면 된다.)
해당 함수에는 Accel Change 파라메터가 있는데 해당 파라메터가 체크되면 오브젝트의 질량이 1로 고정되어 f = 1 * a로 순수 힘만 영향을 주게 된다.
Accel Change이 체크된 상태에서 Add Force에 X축으로 100의 힘을 가한다고 하자 그려면 100 = 1 * a가 되고 a는 100(단위는 이해를 위해 m/s라고 하자)m/s가 되는데 해당 Add Force 함수를 1초 동안 수행시켜 줘야 Add Force가 된 물체는 100m/s에 도달할 것이다.

* Add Impulse 함수
프레임 상관없이 호출하는 것을 전제로 만든 함수이다. 
당신의 게임이 60fps인 경우에 Add Force에 100 * 60을 한 결과와 Add Impulse에 100을 한 결과는 같다. 
해당 함수에는 Vel Change가 있는데 Add Force 함수의 Accel Change 파라메터와 같이 체크되면 오브젝트의 질량을 1로 고정하여 순수 힘만 영향을 주게 된다. 
질량을 고정하는건 같은데 이름이 다른 이유는 다음과 같다. 
Accel Change가 체크된 Add Force 함수의 수식은 원래의 식 f = m * a에서 질량(m)이 1로 무시되어 f = 1 * a = a 요렇게 된다.
Vel Change가 체크된 Add Impulse 함수의 수식은 원래의 식 f = m * a[v * t]에서 질량(m)과 시간(t)이 1로 무시되어 f = 1 * v * 1 = v 요렇게 된다.
Vel Change가 체크된 상태에서 Add Impulse에 X축으로 100의 힘을 가한다고 하자 그려면 100 = 1 * v * 1가 되고 v는 100(단위는 이해를 위해 m/s라고 하자)m/s가 되는데 해당 Add Impulse 함수를 실행한 그 tick에 바로 Add Impulse가 된 물체는 100m/s에 도달할 것이다.

- 인 게임 관련

게임이 시작될 때 자동으로 생성되는 default pawn의 rotation은 고정이다. 따라서 마우스를 움직여 카메라의 시점 위치에 따라 default pawn의 rotation이 바뀔 것이라 생각하는 것은 큰 오산이다.
따라서 카메라 이동에 따른 rotation을 구할 때는 get Actor rotation 말고 get control rotation을 사용해야 한다.
참고로 get control rotation 함수는 언리얼 공식 문서에서 aim rotation이라고 설명이 되어 있는데 컨트롤러를 통해 우리가 게임을 볼 때 마우스가 향하고 있는 곳의 rotation을 반환하는 것이라고 봐도 무방할 것이다.

- 언리얼 버그 관련

언리얼에서 에셋을 추가할 때 맵이 함께 들어있는 에셋들이 있을 것이다. 해당 에셋의 맵을 그냥 더블클릭해서 열려고 하면 진행 상황 표시 창이 멈춰서 어디까지 진행이 되었는지도 모르고 맵이 열리기 까지 굉장히 오래 걸려서 답답한데 이를 해결하기 위해서는 그냥 해당 맵을 한번만 클릭하고 우측클릭을 누르면 언리얼엔진 밑에 쉐이더를 로드하는 부분이 나타나고 해당 쉐이더가 다 읽힌 후에 맵을 더블클릭해서 열어보면 맵이 잘 출력되는 것을 볼 수 있다.

현재 언리얼 엔진 5에 버그가 있어서 새로운 C++ 클래스를 생성하는 경우 매우 주의하여야 한다. 
만약 C++ 클래스를 생성했다면 에디터를 닫고 해당 언리얼 프로젝트 폴더 경로로 들어가서 비주얼 스튜디오 프로젝트 파일인 .sln 파일을 열어준다. 
그 후에 Development Editor 솔루션 구성 상태에서 ctrl + f5로 빌드하고 실행하여 에디터를 연다. 
이렇게 해야만 생성한 C++ 클래스가 에디터에 유지된다. 
위의 방식을 사용하지 않고 C++ 클래스와 연동된 블루프린트를 만들고 작업을 진행한 후에 저장하고 언리얼 에디터를 종료하게 되면 후에 다시 언리얼 에디터를 킨 경우에 C++ 클래스가 에디터에서 사라져 기존에 만들어 놓았던 블루프린트가 부모 클래스를 찾지 못하게 되어 프로젝트 저장에 문제가 생긴다. 
해당 문제가 발생하면 부모 클래스가 없는 블루프린트는 에디터 내에서 삭제가 안돼서 특정 참조 파일을 일일이 경로로 지워주어야 하기에 반드시 사전 방지를 하자. 
추가적으로 해당 현상은 단순히 C++ 클래스의 소스 코드가 바뀐 경우도 포함되기 때문에 C++ 클래스가 새로 생성되거나 내용이 바뀌는 경우 모두 수행하는 것으로 하자.

- Geometry Brush (BSP)
Place Actor 패널에서 Geometry 오브젝트를 배치할 수 있는데 해당 지형 오브젝트들은 브러쉬 타입이 있다.
하나는 더하기, 하나는 빼기인데 이들을 잘 조합하여 지형을 굉장히 빠르게 만들 수 있다.
예를 들어 지형 오브젝트 박스를 판처럼 만들고 더하기 속성을 가지게 하고 게임 맵에 추가했다고 할 때 해당 판에 창문을 박고 싶다면 또 다른 지형 오브젝트 박스를 작은 네모로 만든 후에 빼기 속성을 가지게 하고 아까 만든 지형 판에 가져다가 두면 해당 창문 지형 오브젝트 크기만큼 판 오브젝트가 뚫린다.

- Actor 관련
하나의 Actor는 여러개의 static mesh를 가질 수 있다. 이때 정적 메쉬들의 부모 자식간의 관계가 중요한데 자식 메쉬는 부모 메쉬의 좌표계를 기준으로 움직이게 된다.
즉 부모의 transform 값과 자식의 transform 값은 다르다는 것이다. 부모 메쉬의 좌표가 0,100,200 이라 해도 부모 메쉬의 자식으로 새로운 메쉬를 달았다면 해당 새로운 자식 메쉬의 좌표는 0,0,0이다.
부모 메쉬에 연결되어 있는 모든 자식 메쉬까지 덩어리인 상태에서 정상적으로 물리를 한번에 적용하려면 부모 메쉬의 최상단에 위치한 엑터에만 물리를 활성화 시키고 나머지 스테틱 메쉬들의 물리는 꺼버리자. (각각의 메쉬들의 물리가 모두 활성화 되어 있으면 덩어리였던 물체들이 서로 낑겨 있는 것으로 판단되어 게임이 시작되자마자 사방으로 튕겨져 나갈 수 있다.)

- 충돌체 복잡성 문제
특정 리소스에서 가져온 메쉬에 물리를 활성화했는데 충돌이 불안정하다면 메쉬를 더블 클릭하여 메쉬 편집기에 들어가서 기존 충돌체를 지우고 충돌체에 맞는 형태의 간략화된 충돌체를 새로 지정해 줄 수 있다. (예를 들면 10DOP-Z simplified collision 등등...)

- 버전 관리 관련
Unreal Engine에서는 blueprint의 바이너리 파일 변경 문제를 다루는 것이 용이한 Perforce라는 형상 관리 시스템이 추천된다.
Perforce는 클라우드 시스템이 없고 직접 서버를 구축하여 활용해야 한다.
다른 방식으로는 git LFS를 이용하는 방법이 있다.
단순 git을 사용해서 Unreal Engine 프로젝트를 관리하게 몇가지 문제가 있는데 일단 Unreal Engine 프로젝트의 크기가 크기 때문에 각종 리퀘스트에 걸리는 시간들이 많이 늘어난다.
그리고 blueprint와 같은 바이너리 기능들에 수정이 가해진 것을 git에서 캐치하지 못하기 때문에 blueprint 수정 사항이 제대로 반영이 안될 뿐만 아니라 팀원끼리 같은 blueprint를 수정하고 merge를 하면 정상적으로 merge 진행이 안된다...
따라서 git을 사용하려면 바이너리 파일을 포함하여 대용량 파일들을 따로 관리해주는 git LFS를 함께 사용해야 한다.
사설 서버에서 git LFS를 사용하는 방법은 gitea와 gitlab이 있으며 gitea가 서버 리소스 사용량이 적기에 더 추천된다.
둘 중 어느 것을 사용하던 사설 서버를 구축하는 것이 맘 편하다.